INSERT INTO `reference` (`srl`, `name`, `code`, `header`, `form`, `parameter`, `return`, `tip`, `result`) VALUES
(1, 'fseek', '<textarea id="code" name="code">\r\n#include &lt;stdio.h&gt;\r\n\r\nint main( void)\r\n{\r\n   FILE *fp;\r\n   char  str[1024];\r\n   int   ndx;\r\n\r\n   fp = fopen( "./test.txt", "r");\r\n\r\n   printf( "%sn", fgets( str, 1024, fp));\r\n\r\n// 파일의 시작에서 10번을 건너 띈다.\r\n   fseek( fp, 10, SEEK_SET);              \r\n\r\n   printf( "%sn", fgets( str, 1024, fp));\r\n// 파일의 시작에서 5번을 건너 띈다.\r\n   fseek( fp,  5, SEEK_SET);            \r\n// 현재 위치에서 다시 5번을 건너 띈다.    \r\n   fseek( fp,  5, SEEK_CUR);              \r\n   printf( "%sn", fgets( str, 1024, fp));\r\n\r\n// 파일의 시작에서 5번을 건너 띈다.\r\n   fseek( fp,  -5, SEEK_END);             \r\n   printf( "%sn", fgets( str, 1024, fp));\r\n\r\n   fclose( fp);\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'stdio.h', 'int fseek( FILE *stream, long offset, int whence);', 'FILE *stream	대상 파일 스트림</br>long offset	이동할 바이트 수</br>int whence	시작 시점', 'int	0을 반환, 오류가 발생하면 -1을 반환', '<label style="padding-left:10px;font-size:20px;">추가설명</label>\r\n<table class="table table-bordered">\r\n<thead>\r\n<tr>\r\n<th>whence</th>\r\n<th>설명</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr><td>SEEK_SET</td><td>파일의 시작</td></tr>\r\n<tr><td>SEEK_CUR</td><td>현재 포인터의 위치\r\n</td></tr>\r\n<tr><td>SEEK_END</td><td>파일의 끝</td></tr    >\r\n</tbody>\r\n</table>\r\n', ']$ ./a.out<br>\r\n0123456789abcdef<br>\r\nabcdef<br>\r\nabcdef<br>\r\nbcdef<br>\r\n]$<br>'),
(6, 'isdigit', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''1''; \r\n   int   ch2 = ''a'';\r\n   int   ch3 = 256;  // 아스키값 이상\r\n   \r\n   if ( isdigit( ch1))  \r\n      printf( "%c(x%03x)는 숫자 문자입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%03x)는 숫자 문자가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( isdigit( ch2))\r\n      printf( "%c(x%03x)는 숫자 문자입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%03x)는 숫자 문자가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( isdigit( ch3))\r\n      printf( "%c(x%03x)는 숫자 문자입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%03x)는 숫자 문자가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isdigit( int c)', 'int c	판별할 문자', ' 0 !=	c가 숫자 문자, ''0''~''9''<br> 0 =	c는 숫자 문자가 아님', '인수로 받은 문자가 숫자 문자인( ''0''~''9'')지를 판별합니다.', ']$ ./a.out<br>\r\n1(x031)는 숫자 문자입니다.<br>\r\na(x061)는 숫자 문자가 아닙니다.<br>\r\n(x100)는 숫자 문자가 아닙니다.'),
(8, 'iscntrl', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''\\t'';   // 탭 문자\r\n   int   ch2 = ''\\n'';   // 엔터 문자\r\n   int   ch3 = ''a'';   \r\n   \r\n   if ( iscntrl( ch1))  \r\n      printf( "%c는 제어 문자입니다.\\n", ch1);\r\n   else\r\n      printf( "%c는 제어 문자가 아닙니다.\\n", ch1);\r\n\r\n   if ( iscntrl( ch2))\r\n      printf( "%c는 제어 문자입니다.\\n", ch2);\r\n   else\r\n      printf( "%c는 제어 문자가 아닙니다.\\n", ch2);\r\n\r\n   if ( iscntrl( ch3))\r\n      printf( "%c는 제어 문자입니다.\\n", ch3);\r\n   else\r\n      printf( "%c는 제어 문자가 아닙니다.\\n", ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int iscntrl( int c)', 'int c	판별할 문자', '0 !=	c가 제어 문자 <br>0 =	c는 제어 문자가 아님', '인수로 받은 문자가 제어문자인지를 판별합니다.', ']$ ./a.out<br>\r\n         는 제어 문자입니다.<br>\r\n		 \r\n는 제어 문자입니다.<br>\r\na는 제어 문자가 아닙니다.<br>\r\n'),
(9, 'isblank', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''\\t'';   // 탭 문자\r\n   int   ch2 = '' '';    // 공백 문자\r\n   int   ch3 = ''\\n'';   // 엔터 문자\r\n   int   ch4 = ''a'';   \r\n   \r\n   if ( isblank( ch1))  \r\n      printf( "%c(x%02x)는 탭 또는 공백문자입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%02x)는 탭 또는 공백문자가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( isblank( ch2))\r\n      printf( "%c(x%02x)는 탭 또는 공백문자입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%02x)는 탭 또는 공백문자가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( isblank( ch3))\r\n      printf( "%c(x%02x)는 탭 또는 공백문자입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%02x)는 탭 또는 공백문자가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   if ( isblank( ch4))\r\n      printf( "%c(x%02x)는 탭 또는 공백문자입니다.\\n", ch4, ch4);\r\n   else\r\n      printf( "%c(x%02x)는 탭 또는 공백문자가 아닙니다.\\n", ch4, ch4);\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isblank( int c)', 'int c	판별할 문자', '0 !=	c가 공백문자 또는 탭 문자<br> 0 =	c는 공백문자도 탭 문자도 아님', '인수로 받은 문자가 공백문자 또는 탭 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n              (x09)는 탭 또는 공백문자입니다.<br>\r\n (x20)는 탭 또는 공백문자입니다.<br>\r\n\r\n(x0a)는 탭 또는 공백문자가 아닙니다.<br>\r\na(x61)는 탭 또는 공백문자가 아닙니다.<br>'),
(10, 'isascii', '<textarea name="code" id="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = 13; \r\n   int   ch2 = ''a'';\r\n   int   ch3 = 256;  // 아스키값 이상\r\n   \r\n   if ( isascii( ch1))  \r\n      printf( "%c(x%03x)는 ASCII입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%03x)는 ASCII가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( isascii( ch2))\r\n      printf( "%c(x%03x)는 ASCII입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%03x)는 ASCII가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( isascii( ch3))\r\n      printf( "%c(x%03x)는 ASCII입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%03x)는 ASCII가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   return 0;\r\n}\r\n<textarea>', 'ctype.h', 'int isascii( int c)', ' int c	판별할 문자', ' 0 !=	c가 ASCII <br>0 =	c는 ASCII가 아님', '인수로 받은 문자가 ASCII 문자 인지를 판별합니다.', ']$ ./a.out<br>\r\n(x00d)는 ASCII입니다.<br>\r\na(x061)는 ASCII입니다.<br>\r\n(x100)는 ASCII 아닙니다.<br>'),
(11, 'isalpha', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''#'';\r\n   int   ch2 = ''a'';\r\n   int   ch3 = ''1'';\r\n   \r\n   if ( isalpha( ch1))\r\n      printf( "%c는 영문자입니다.\\n", ch1);\r\n   else\r\n      printf( "%c는 영문자가 아닙니다.\\n", ch1);\r\n\r\n   if ( isalpha( ch2))\r\n      printf( "%c는 영문자입니다.\\n", ch2);\r\n   else\r\n      printf( "%c는 영문자가 아닙니다.\\n", ch2);\r\n\r\n   if ( isalpha( ch3))\r\n      printf( "%c는 영문자입니다.\\n", ch3);\r\n   else\r\n      printf( "%c는 영문자가 아닙니다.\\n", ch3);\r\n      \r\n   return 0;\r\n}\r\n<textarea>', 'ctype.h', 'int isalpha( int c)', 'int c	판별할 문자', '0 !=	c가 영문자<br> 0 =	c는 영문자가 아님', '인수로 받은 문자가 영문자 인지를 판별합니다.', ']$ ./test<br>\r\n#는 영문자가 아닙니다.<br>\r\na는 영문자입니다.<br>\r\n1는 영문자가 아닙니다.<br>'),
(12, 'isalnum', '<textarea name="code" id="code">\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''#'';\r\n   int   ch2 = ''a'';\r\n   int   ch3 = ''1'';\r\n   \r\n   if ( isalnum( ch1))\r\n      printf( "%c는 영문이나 숫자입니다.\\n", ch1);\r\n   else\r\n      printf( "%c는 영문이나 숫자가 아닙니다.\\n", ch1);\r\n\r\n   if ( isalnum( ch2))\r\n      printf( "%c는 영문이나 숫자입니다.\\n", ch2);\r\n   else\r\n      printf( "%c는 영문이나 숫자가 아닙니다.\\n", ch2);\r\n\r\n   if ( isalnum( ch3))\r\n      printf( "%c는 영문이나 숫자입니다.\\n", ch3);\r\n   else\r\n      printf( "%c는 영문이나 숫자가 아닙니다.\\n", ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isalnum( int c)', 'int c	판별할 문자', '0 !=	c가 영문자 또는 숫자<br> 0 =	c가 영문자도 숫자도 아님', '인수로 받은 문자가 영문자 인지 숫자 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n#는 영문이나 숫자가 아닙니다.<br>\r\na는 영문이나 숫자입니다.<br>\r\n1는 영문이나 숫자입니다.<br>\r\n'),
(13, 'strncmp', '<textarea id="code" name="code">\r\n#include \r\n#include \r\n\r\nint main( void)\r\n{\r\n   char  str_apple[]  = "apple";\r\n   char  str_apple2[] = "   apple";\r\n   char  str_banana[] = "banana";\r\n   char  str_appleII[]= "appleII";\r\n                     \r\n   printf( "%s with %s = %d\\n", str_apple, str_apple  , strncmp( str_apple, str_apple  , 5) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple2 , strncmp( str_apple, str_apple2 , 5) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_banana , strncmp( str_apple, str_banana , 5) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_appleII, strncmp( str_apple, str_appleII, 5) );\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strncmp( const char *s1, const char *s2, size_t n);', 'char *s1	비교할 대상 문자열<br> char *s2	비교할 문자열<br> size_t n	비교할 문자의 개수', '0 = 결과 값이면 s1 = s2<br> 0 < 결과 값이면 s1 > s2<br> 0 > 결과 값이면 s1 < s2', 'strncmp는 2개의 문자열을 지정한 문자 개수까지만 비교합니다.', ']$ ./a.out<br>\r\napple with apple = 0<br>\r\napple with    apple = 65<br>\r\napple with banana = -1<br>\r\napple with appleII = 0<br>'),
(14, 'strcmp', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str_apple[]  = "apple";\r\n   char  str_apple2[] = "   apple";\r\n   char  str_banana[] = "banana";\r\n   char  str_appleII[]= "appleII";\r\n                     \r\n   printf( "%s with %s = %d\\n", str_apple, str_apple  , strcmp( str_apple, str_apple  ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple2 , strcmp( str_apple, str_apple2 ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_banana , strcmp( str_apple, str_banana ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_appleII, strcmp( str_apple, str_appleII) );\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strcmp( const char *s1, const char *s2);', 'char *s1	비교할 대상 문자열<br> char *s2	비교할 문자열', '0 = 결과 값이면 s1 = s2,br> 0 < 결과 값이면 s1 > s2<br> 0 > 결과 값이면 s1 < s2', 'strcmp는 2개의 문자열을 비교하는 함수이며, 문자열의 길이가 크고 작음을 비교하는 것이 아니라 첫번재 문자부터 차례로 바이트의 크기를 비교합니다.', ']$ ./a.out<br>\r\napple with apple = 0<br>\r\napple with    apple = 1   -> 공백이 있는 문자열이 더 길지만 공백문자가 ''a''보다 작음<br>\r\napple with banana = -1<br>\r\napple with appleII = -1<br>'),
(15, 'strncat', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str1[50] = "forum";\r\n   char  str2[50] = "forum";\r\n                     \r\n   printf( "%s\\n", strncat( str1, ".falinux.com fighting!!", 21));\r\n   printf( "%s\\n", strncat( str2, ".falinux.com fighting!!", 12));\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'char * strncat( char *dest, const char *src, size_t n);', 'string.h', 'char *dest	연결될 문자열<br> char *src	붙여 넣기할 문자열<br> size_t sz	src 문자열에서 붙여 넣기할 문자 개수', '2개의 문자열을 합쳐진 문자열을 반환', 'strcat와 마찬가지로 2개의 문자열 인수를 받아서 1개의 문자열로 합칩니다. 대신에 복사할 2번째 문자열 중에 앞에서 몇 번째까지를 붙여 넣기 할지를 지정할 수 있습니다.\r\n주의해야할 점은 합쳐진 문자열을 첫번째 인수의 포인터 배열에 저장된다는 것입니다. 그러므로 첫번째 인수의 포이터나 배열은 합쳐진 문자열 크기만큼의 메모리를 확보해야 합니다. 즉, 첫번째와 두번째 인수의 문자열 크기를 확인하고 새로운 메모리를 확보하여 합쳐진 문자열을 넣지 않는다는 뜻입니다.\r\nstrncat는 첫번째 인수의 메모리에서 ''\\0''을 찾아 그 부분부터 2번째 인수의 문자열의 문자를 지정한 개수 만큼 차례로 복사해 나갑니다. 예제를 참고하여 주십시오.', ']$ ./a.out<br>\r\nforum.falinux.com fighting<br>\r\nforum.falinux.com<br>'),
(16, 'strcat', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str[50] = "forum";\r\n                     \r\n   strcat( str, ".falinux.com");           \r\n   printf( "%s\\n", str);\r\n   return 0;\r\n}\r\n</textarea>', 'char * strcat( char *dest, const char *src);', 'string.h', 'char *dest	연결될 문자열<br> char *src	연결할 문자열', '2개의 문자열을 합쳐진 문자열을 반환', '  2개의 문자열 인수를 받아서 1개의 문자열로 합칩니다.\r\n  주의해야할 점은 합쳐진 문자열을 첫번째 인수의 포인터 배열에 저장된다는 것입니다. 그러므로 첫번째 인수의 포이터나 배열은 합쳐진 문자열 크기만큼의 메모리를 확보해야 합니다. 즉, 첫번째와 두번째 인수의 문자열 크기를 확인하고 새로운 메모리를 확보하여 합쳐진 문자열을 넣지 않는다는 뜻입니다.\r\n  strcat는 첫번째 인수의 메모리에서 ''\\0''을 찾아 그 부분부터 2번째 인수의 문자열을 차례로 복사해 나갑니다. 예제를 참고하여 주십시오.', ']$ ./a.out<br>\r\nforum.falinux.com<br>'),
(17, 'sigemptyset', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <signal.h>\r\n\r\nint main( void)\r\n{\r\n   sigset_t set;\r\n\r\n   sigemptyset( &set);        // 시그널 집합 변수의 내용을 모두 제거합니다.\r\n   sigaddset( &set, SIGINT);  // 시그널 집합 변수에 SIGINT를 추가합니다.\r\n\r\n   // SIGINT 가 등록되었는지 확인합니다.\r\n\r\n   switch( sigismember( &set, SIGINT))\r\n   {\r\n   case 1   :  printf( "SIGINT는 포함되어 있습니다.\\n");\r\n               break;\r\n   case 0   :  printf( "SIGINT는 없습니다.\\n");\r\n               break;\r\n   default  :  printf( "sigismember() 호출에 실패했습니다.\\n");\r\n   }\r\n\r\n   // SIGSYS 가 등록되었는지 확인합니다.\r\n\r\n   switch( sigismember( &set, SIGSYS))\r\n   {\r\n   case 1   :  printf( "SIGSYS는 포함되어 있습니다.\\n");\r\n               break;\r\n   case 0   :  printf( "SIGSYS는 없습니다.\\n");\r\n               break;\r\n   default  :  printf( "sigismember() 호출에 실패했습니다.\\n");\r\n   }\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'signal.h', 'int sigemptyset(sigset_t *set);', 'sigset_t *set	시그널 집합 변수', '0	집합 변수를 성공적으로 비웠음<br> -1	실패했음', '<table class="table">\r\n<thead>\r\n	<tr>\r\n		<th>\r\n			시그널 이름\r\n		</th>\r\n		<th>\r\n			내용\r\n		</th>\r\n	</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>\r\nSIGABRT\r\n</td>\r\n<td>\r\nabord() 함수를 호출하면 발생하며, 이 시그널을 받으면 코어 덤프하고 프로그램은 종료됩니다.\r\n</td>\r\n</tr>\r\n<tr>\r\n<td>\r\nSIGALRM\r\n</td>\r\n<td>\r\nalarm() 함수를 호출하면 발생하며, 이 시그널을 받으면 프로세스는 종료됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGBUS\r\n</td>\r\n<td>	\r\n하드웨어 결함이 탐지되면 발생하며, 이 시그널을 받으면 프로세스는 종료됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGCHLD\r\n</td>\r\n<td>	\r\n자식 프로세스가 종료될 때 부모 프로세스에 전달됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGCONT\r\n</td>\r\n<td>	\r\n중단된 프로세스가 이 시그널을 받으면 다시 활성화되어 실행이되며, 이미 실행 중이라면 무시됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGFPE\r\n</td>\r\n<td>	\r\n0으로 나누거나 부동소수점 오류 등이 생기면 발생하며, 프로세스는 코어 덤프 후에 종료됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGHUP\r\n</td>\r\n<td>	\r\n터미널 연결이 끝어지면 이 터미널과 연결된 세션 리더 또는 세션에 속한 모든 프로세스에게 전달되면, 전달 받은 프로세스는 종료됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGILL\r\n</td>\r\n<td>	\r\n불법 명령어를 실행할 때 발생하며, 이 시그널을 받으면 코어 덤프 후에 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGINT\r\n</td>\r\n<td>	\r\n터미널에서 인터럽트 키 중의 하나인 Ctrl-C 를 눌렀을 때 발생하며, 프로세스는 종료됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGKILL\r\n</td>\r\n<td>	\r\n프로세스를 종료하기 위해 전송되며, 시그널을 받은 프로세스는 반드시 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGPIPE\r\n</td>\r\n<td>	\r\n이미 닫힌 파이프에 쓰기를 할 때 발생하며, 이 시그널을 받으면 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGQUIT\r\n</td>\r\n<td>	\r\n터미널에서 종료키인 Ctrl-\\를 눌렀을 때 발생하며, 프로세스는 코어 덤프 후에 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGSEGV\r\n</td>\r\n<td>	\r\n잘못된 메모리 주소를 접근할 때 발생하며, 이 시그널을 받은 프로세스는 코어 덤프 후에 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGSTOP\r\n</td>\r\n<td>	\r\n프로세스를 멈추기 위해 보내지며, 이 시그널을 받은 프로세스는 반드시 멈춥니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGSYS\r\n</td>\r\n<td>	\r\n잘못된 시스템 호출을 했을 때 보내지며, 이 시그널을 받은 프로세스는 코어 덤프 후에 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGTERM\r\n</td>\r\n<td>	\r\n프로세스가 종료 전에 처리해야될 작업을 처리할 수 있도록 종료 전에 미리 보내 집니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGSTP\r\n</td>\r\n<td>	\r\n터미널에서 프로세스를 잠시 멈추게 하기 위해 Ctrl-Z키를 눌렀을 때 전송되며, 이 시그널을 받은 프로세스는 멈춤이 됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGTTIN\r\n</td>\r\n<td>	\r\n백그라운드에서 작업 중인 프로세스가 표준 입력을 사용하려 할 때 현재 실행 중인 프로세스에 전송되며, 이 시그널을 받은면 멈춤상태가 됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGTTOU\r\n</td>\r\n<td>	\r\n백그라운드에서 작업 중인 프로세스가 표준 출력을 사용하려 할 때 현재 실행 중인 프로세스에 전송되며, 이 시그널을 받은면 멈춤상태가 됩니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGURS1\r\n</td>\r\n<td>	\r\n사용자 정의로 사용할 수 있는 시그널로, 이 시그널을 받으면 프로세스는 종료합니다.\r\n</td>\r\n</tr>\r\n\r\n<tr>\r\n<td>\r\nSIGURS2\r\n</td>\r\n<td>\r\n사용자 정의로 사용할 수 있는 시그널로, 이 시그널을 받으면 프로세스는 종료합니다.\r\n</td>\r\n</tr>\r\n', ']$ ./a.out<br>\r\nSIGINT는 포함되어 있습니다.<br>\r\nSIGSYS는 없습니다.<br>\r\n]$ <br>'),
(18, 'strtok', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{           \r\n   char   str[] = "forum falinux com";\r\n   char	*ptr;\r\n   int	 ndx;\r\n\r\n   printf( "함수 호출 전: %s\\n", str); \r\n\r\n   ptr = strtok( str, " ");\r\n   printf( "%s\\n", ptr); \r\n   \r\n   while( ptr = strtok( NULL, " "))\r\n   {\r\n	   printf( "%s\\n", ptr); \r\n   }\r\n   \r\n   printf( "함수 호출 후: %s\\n", str); \r\n\r\n   // 함수 호출 후에는 원본 문자열의 내용이 바뀌므로 주의해야 합니다.\r\n        \r\n   printf( "문자열의 변화\\n", str); \r\n  \r\n   for( ndx=0; ndx < 17; ndx++)\r\n	   printf( "%c %d\\n", str[ndx], str[ndx]); \r\n	   \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char *strtok(char *restrict s1, const char *restrict s2);', 'char *s1	자르기 대상 문자열 <BR>char *s2	잘라 내기 위한 문자 모임', 'char *	잘라 내기한 문자열의 첫번째 포인터를 반환하며, 문자열이 없다면 NULL을 반환', '더 이상 구할 문자열이 없다면 NULL이 반환됩니다.<br>\r\nstrtok()는 잘라 낸 문자열을 구하기 위해 대상 문자열에 NULL을 추가합니다. ', ']$ ./a.out<br>\r\n함수 호출 전: forum falinux com<br>\r\nforum<br>\r\nfalinux<br>\r\ncom<br>\r\n함수 호출 후: forum<br>\r\n문자열의 변화<br>\r\nf 102<br>\r\no 111<br>\r\nr 114<br>\r\nu 117<br>\r\nm 109<br>\r\n 0<br>\r\nf 102<br>\r\na 97<br>\r\nl 108<br>\r\ni 105<br>\r\nn 110<br>\r\nu 117<br>\r\nx 120<br>\r\n 0<br>\r\nc 99<br>\r\no 111<br>\r\nm 109<br>'),
(19, 'strpbrk', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com";\r\n\r\n   printf( "%s\\n", strpbrk( str, "jklmn"));\r\n  \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char *strpbrk(const char *s1, const char *s2);', 'char *s1	검색 대상 문자열<br> char *s2	검색에 사용되는 문자들의 모임', 'char *	찾은 문자열의 포인터를 반환하며, 찾지를 못했다면 NULL을 반환', '문자열에서 지정된 문자들이 있는 위치의 문자열 포인터를 반환합니다.', ']$ ./a.out<br>\r\nm.falinux.com<br>'),
(20, 'strcspn', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com";\r\n\r\n   printf( "%d\\n", strcspn( str, "rstuvwxyz"));\r\n  \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'size_t strcspn(const char *s1, const char *s2);', 'char *s1	검색 대상 문자열<br> char *s2	검색에 사용되는 문자들의 모임', 'size_t	문자열의 길이를 반환합니다.', '문자열에서 지정된 문자들이 없는 초기 문자열의 길이를 검색합니다.\r\nstrcspn()은 strspn()과 정 반대로 검색 대상의 문자열에 대해 첫번째 바이트부터 차례 대로 검색하면서 두번째 인수의 문자열에 포함되는 문자인지를 확인합니다. 그러다가 2번째 인수에 포함되는 문자를 만나면 그 전까지의 문자열 길이를 반환합니다.', ']$ ./a.out<br>\r\n2'),
(21, 'strspn', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com";\r\n\r\n   printf( "%d\\n", strspn( str, "uovrwxf"));\r\n  \r\n   return 0;\r\n}\r\n<textarea>', 'string.h', 'size_t strspn(const char *s1, const char *s2);', 'char *s1	검색 대상 문자열 <br>char *s2	검색에 사용되는 문자들의 모임', 'size_t	문자열의 길이를 반환합니다.', '문자열에서 지정된 문자들로 구성된 초기 문자열의 길이를 검색합니다.<br>\r\nstrspn()은 strcspn()과 정 반대로 검색 대상의 문자열에 대해 첫번째 바이트부터 차례 대로 검색하면서 두번째 인수의 문자열에 포함되는 문자인지를 확인합니다. 그러다가 2번째 인수에 포함되지 않는 문자를 만나면 그 전까지의 문자열 길이를 반환합니다.', ']$ ./a.out<br>\r\n4'),
(22, 'strstr', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com - embedded linux forum";\r\n\r\n   printf( "%s\\n", strstr( str, "linux"));\r\n  \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char *strstr( const char *str1, const char *str2)', ' char *str1	검색 대상 문자열 <br>char *str2	찾는 문자열', '찾고자 하는 문자열이 발견된 첫번째 위치의 포인터를 반환합니다. 찾지 못하면 NULL을 반환합니다.', '문자열에서 임의의 문자열이 시작하는 위치를 구합니다. 주의하실 것은 찾은 위치를 포인터로 반환합니다. 발견된 위치에 대해 바이트의 몇 번째가 아닙니다.', ']$ ./a.out<br>\r\nlinux.com - embedded linux forum'),
(23, 'strrchr', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com";\r\n\r\n   printf( "%s\\n", strrchr( str, ''f''));\r\n  \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char *strrchr( const char *str, int chr)', 'char *str	검색 대상 문자열 <br>int chr	찾는 문자', '찾고자 하는 문자가 발견된 마지막 위치의 포인터를 반환합니다. 찾지 못하면 NULL을 반환합니다.', '문자열에서 임의의 문자열이 시작하는 위치를 구합니다. 주의하실 것은 찾은 위치를 포인터로 반환합니다. 발견된 바이트의 몇 번째가 아닙니다.', ']$ ./a.out<br>\r\nfalinux.com'),
(24, 'strchr', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char   *str = "forum.falinux.com";\r\n\r\n   printf( "%s\\n", strchr( str, ''a''));\r\n  \r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char *strchr( const char *str, int chr)', 'char *str	검색 대상 문자열 <br>int c	찾는 문자', '찾고자 하는 문자가 발견된 첫번째의 포인터를 반환합니다. 찾지 못하면 NULL을 반환합니다.', '문자열에서 임의의 문자가 처음으로 발견된 위치를 구합니다. 주의하실 것은 찾은 위치를 포인터로 반환합니다. 발견된 바이트의 몇 번째가 아닙니다.', ']$ ./a.out<br>\r\nalinux.com'),
(25, 'strlen', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char *str = "forum.falinux.com";\r\n  \r\n   printf( "%d\\n", strlen( str));\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'size_t strlen( const char *str)', 'char *str	길이를 구할 문자열', '문자열 길이를 바이트 단위로 반환합니다.', '문자열의 길이를 구합니다.', ']$ ./a.out<br>\r\n17'),
(26, 'strdup', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char *ptr;\r\n  \r\n   ptr = strdup( "forum.falinux.com");\r\n   printf( "%s\\n", ptr);\r\n\r\n   return 0;\r\n}\r\n<textarea>', 'string.h', 'char * strdup( const char *str);', 'char *str	복사할 문자열', '확보된 문자열 메모리의 첫 주소를 반환', '복사할 문자열 크기에 맞는 메모리를 확보한 후 문자열을 복사한 후, 확보한 메모리의 포인터를 반환해 줍니다.', ']$ ./a.out<br>\r\nforum.falinux.com'),
(27, 'strncpy', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str_buffer[50];\r\n   char *ptr;\r\n  \r\n   ptr = strncpy( str_buffer, "forum.falinux.com", 5);\r\n   printf( "%s\\n", str_buffer);\r\n   printf( "%s\\n", ptr);\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strncpy( char *dest, const char *src, size_t n);', 'char *dest	복사할 위치<br>char *src	원문 문자열 <br>size_t n	문자열에서 복사할 길이', '복사한 문자열을 반환', '문자열을 지정한 길이 만큼 복사한다.', ']$ ./a.out<br>\r\nforum<br>\r\nforum'),
(28, 'strcpy', '<textarea id="code" name="code">\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str_buffer[50];\r\n   char *ptr;\r\n  \r\n   ptr = strcpy( str_buffer, "forum.falinux.com");\r\n   printf( "%s\\n", str_buffer);\r\n   printf( "%s\\n", ptr);\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strcpy( char *dest, const char *src);', 'char *dest	복사할 위치<br> char *src	원문 문자열', '복사한 문자열을 반환', '문자열을 복사한다.', ']$ ./a.out<br>\r\nforum.falinux.com<br>\r\nforum.falinux.com'),
(29, 'strncasecmp', '<textarea id=''code'' name=''code''>\r\n#include \r\n#include \r\n\r\nint main( void)\r\n{\r\n   char  str_apple[]  = "apple";\r\n   char  str_apple2[] = "Apple";\r\n   char  str_apple3[] = "  Apple";\r\n   char  str_appleII[]= "AppleII";\r\n                     \r\n   printf( "%s with %s = %d\\n", str_apple, str_apple  , strncasecmp( str_apple, str_apple  , 3) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple2 , strncasecmp( str_apple, str_apple2 , 3) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple3 , strncasecmp( str_apple, str_apple3 , 3) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_appleII, strncasecmp( str_apple, str_appleII, 3) );\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strncasecmp( const char *s1, const char *s2, size_t n);', 'char *s1	비교할 대상 문자열 <br>char *s2	비교할 문자열', '0 = 결과 값이면 s1 = s2<br> 0 < 결과 값이면 s1 > s2<br> 0 > 결과 값이면 s1 < s2', 'strncasecmp는 대소문자를 무시하고 2개의 문자열을 지정한 문자 개수까지만 비교합니다.\r\n', ']$ ./a.out<br>\r\napple with apple = 0<br>\r\napple with Apple = 0<br>\r\napple with   Apple = 65<br>\r\napple with AppleII = 0'),
(30, 'strcasecmp', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main( void)\r\n{\r\n   char  str_apple[]  = "apple";\r\n   char  str_apple2[] = "Apple";\r\n   char  str_apple3[] = "  Apple";\r\n   char  str_appleII[]= "AppleII";\r\n                     \r\n   printf( "%s with %s = %d\\n", str_apple, str_apple  , strcasecmp( str_apple, str_apple  ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple2 , strcasecmp( str_apple, str_apple2 ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_apple3 , strcasecmp( str_apple, str_apple3 ) );\r\n   printf( "%s with %s = %d\\n", str_apple, str_appleII, strcasecmp( str_apple, str_appleII) );\r\n\r\n   return 0;\r\n}\r\n</textarea>', 'string.h', 'char * strcasecmp( const char *s1, const char *s2, size_t n);', 'char *s1	비교할 대상 문자열 <br>char *s2	비교할 문자열', '0 = 결과 값이면 s1 = s2 <br>0 < 결과 값이면 s1 > s2 <br>0 > 결과 값이면 s1 < s2', 'strcasecmp는 대소문자를 무시하고 2개의 문자열을 비교합니다.', ']$ ./a.out<br>\r\napple with apple = 0<br>\r\napple with Apple = 0<br>\r\napple with   Apple = 65<br>\r\napple with AppleII = -105'),
(31, 'tolower', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char  str[] = "0xAF1Agh!@#";\r\n   int   ndx;\r\n  \r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      str[ndx] = (char)tolower( str[ndx]);\r\n   }\r\n   printf( "%s\\n", str);\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int tolower( int ch)', 'int c	변환할 문자', 'c가 대문자일 때만 소문자로 변환하여 반환하고, 대문자가 아니라면 그대로 반환', '인수로 받은 문자가 대문자이면 소문자로 변환하여 반환합니다.', ']$ ./a.out<br>\r\n0xaf1agh!@#'),
(32, 'toupper', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char  str[] = "0xaf1Agh!@#";\r\n   int   ndx;\r\n  \r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      str[ndx] = (char)toupper( str[ndx]);\r\n   }\r\n   printf( "%s\\n", str);\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int toupper( int ch)', 'int c	변환할 문자', 'c가 소문자일 때만 대문자로 변환하여 반환하고,<br> 소문자가 아니라면 그래도 반환', '소문자를 대문자로 변환하여 반환합니다.', ']$ ./a.out<br>\r\n0XAF1AGH!@#'),
(33, 'isxdigit', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char *str = "0xaf1Agh\\n@";\r\n   int   ch;\r\n   int   ndx;\r\n\r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      ch = str[ndx];\r\n      if ( isxdigit( ch))\r\n         printf( "%c(x%02x)는 16진수 수치 문자입니다.\\n", ch, ch);\r\n      else\r\n         printf( "%c(x%02x)는 16진수 수치 문자가 아닙니다.\\n", ch, ch);\r\n   }\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isxdigit( int c)', 'int c	판별할 문자', '0 !=	c는 16진수 수치 문자 <br>0 =	c는 16진수 수치 문자가 아님', '인수로 받은 문자가 16진수 수치 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n0(x30)는 16진수 수치 문자입니다.<br>\r\nx(x78)는 16진수 수치 문자가 아닙니다.<br>\r\na(x61)는 16진수 수치 문자입니다.<br>\r\nf(x66)는 16진수 수치 문자입니다.<br>\r\n1(x31)는 16진수 수치 문자입니다.<br>\r\nA(x41)는 16진수 수치 문자입니다.<br>\r\ng(x67)는 16진수 수치 문자가 아닙니다.<br>\r\nh(x68)는 16진수 수치 문자가 아닙니다.<br>\r\n<br>\r\n(x0a)는 16진수 수치 문자가 아닙니다.<br>\r\n@(x40)는 16진수 수치 문자가 아닙니다.'),
(34, 'isupper', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char *str = "1Ab\\n@";\r\n   int   ch;\r\n   int   ndx;\r\n\r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      ch = str[ndx];\r\n      if ( isupper( ch))\r\n         printf( "%c(x%02x)는 대문자입니다.\\n", ch, ch);\r\n      else\r\n         printf( "%c(x%02x)는 대문자가 아닙니다.\\n", ch, ch);\r\n   }\r\n   return 0;\r\n}\r\n</textarea>\r\n', 'ctype.h', 'int isupper( int c)', 'nt c	판별할 문자', '0 !=	c는 대문자 <br>0 =	c는 대문자 아님', '인수로 받은 문자가 대문자인지를 판별합니다.', ']$ ./a.out<br>\r\n1(x31)는 대문자가 아닙니다.<br>\r\nA(x41)는 대문자입니다.<br>\r\nb(x62)는 대문자가 아닙니다.<br>\r\n<br>\r\n(x0a)는 대문자가 아닙니다.<br>\r\n@(x40)는 대문자가 아닙니다.'),
(35, 'isspace', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char *str = "1 A\\n\\f\\t\\v\\r!@#";\r\n   int   ch;\r\n   int   ndx;\r\n\r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      ch = str[ndx];\r\n      if ( isspace( ch))\r\n         printf( "%c(x%02x)는 공백문자입니다.\\n", ch, ch);\r\n      else\r\n         printf( "%c(x%02x)는 공백문자가 아닙니다.\\n", ch, ch);\r\n   }\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isspace( int c)', 'int c	판별할 문자', '0 !=	c는 공백 문자<br>0 =	c는 공백 문자가 아님', '인수로 받은 문자가 공백 문자(공백, 개행(''\\n''), 종이넘기(''\\f''), 탭(''\\t'', ''\\v''), 복귀(''\\r'') 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n1(x31)는 공백문자가 아닙니다.<br>\r\n (x20)는 공백문자입니다.<br>\r\nA(x41)는 공백문자가 아닙니다.<br>\r\n<br>\r\n(x0a)는 공백문자입니다.<br>\r\n<br>\r\n                  <---- 여기서 화면이 Clear 됩니다. ----><br>\r\n<br>\r\n        (x0c)는 공백문자입니다.<br>\r\n        (x09)는 공백문자입니다.<br>\r\n<br>\r\n(x0b)는 공백문자입니다.<br>\r\n(x0d)는 공백문자입니다.<br>\r\n!(x21)는 공백문자가 아닙니다.<br>\r\n@(x40)는 공백문자가 아닙니다.<br>\r\n#(x23)는 공백문자가 아닙니다.<br>\r\n'),
(36, 'ispunct3', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   char *str = "1 A!@#";\r\n   int   ch;\r\n   int   ndx;\r\n\r\n   for ( ndx= 0; ndx < strlen( str); ndx++)\r\n   {\r\n      ch = str[ndx];\r\n      if ( ispunct( ch))\r\n         printf( "%c(x%02x)는 구획 문자입니다.\\n", ch, ch);\r\n      else\r\n         printf( "%c(x%02x)는 구획 문자가 아닙니다.\\n", ch, ch);\r\n   }\r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int ispunct( int c)', ' int c	판별할 문자', ' 0 !=	c가 구획 문자<br>0 =	c는 구획 문자가 아님', '인수로 받은 문자가 구획 문자(공백, 영문자, 숫자 이외의 출력 가능 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n1(x31)는 구획 문자가 아닙니다.<br>\r\n (x20)는 구획 문자가 아닙니다.<br>\r\nA(x41)는 구획 문자가 아닙니다.<br>\r\n!(x21)는 구획 문자입니다.<br>\r\n@(x40)는 구획 문자입니다.<br>\r\n#(x23)는 구획 문자입니다.'),
(37, 'isprint', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''1''; \r\n   int   ch2 = '' '';\r\n   int   ch3 = ''\\t'';  // 탭 문자\r\n   \r\n   if ( isprint( ch1))  \r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( isprint( ch2))\r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( isprint( ch3))\r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isprint( int c)', 'int c	판별할 문자', '0 !=	c가 프린트 가능 문자, 공백문자도 포함<br>0 =	c는 프린트 가능 문자가 아님', '인수로 받은 문자가 인쇄 가능 문자인지를 판별합니다. isgraph()와의 차이점은 공백문자도 인쇄 가능 문자로 판별합니다.', ']$ ./a.out<br>\r\n1(x31)는 인쇄 가능 문자입니다.<br>\r\n(x20)는 인쇄 가능 문자입니다.<br>\r\n(x09)는 인쇄 가능 문자가 아닙니다.<br>'),
(38, 'islower', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''a''; \r\n   int   ch2 = ''A'';\r\n   int   ch3 = ''1'';\r\n   \r\n   if ( islower( ch1))  \r\n      printf( "%c(x%02x)는 소문자입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%02x)는 소문자가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( islower( ch2))\r\n      printf( "%c(x%02x)는 소문자입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%02x)는 소문자가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( islower( ch3))\r\n      printf( "%c(x%02x)는 소문자입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%02x)는 소문자가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int islower( int c)', 'int c	판별할 문자', '0 !=	c가 소문자 <br>0 =	ch는 소문자가 아님', '인수로 받은 문자가 소문자인지를 판별합니다.', ']$ ./a.out<br>\r\na(x61)는 소문자입니다.<br>\r\nA(x41)는 소문자가 아닙니다.<br>\r\n1(x31)는 소문자가 아닙니다.'),
(39, 'isgraph', '<textarea id=''code'' name=''code''>\r\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\nint main( void)\r\n{\r\n   int   ch1 = ''1''; \r\n   int   ch2 = '' '';\r\n   int   ch3 = ''\\t'';  // 탭 문자\r\n   \r\n   if ( isgraph( ch1))  \r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch1, ch1);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch1, ch1);\r\n\r\n   if ( isgraph( ch2))\r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch2, ch2);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch2, ch2);\r\n\r\n   if ( isgraph( ch3))\r\n      printf( "%c(x%02x)는 인쇄 가능 문자입니다.\\n", ch3, ch3);\r\n   else\r\n      printf( "%c(x%02x)는 인쇄 가능 문자가 아닙니다.\\n", ch3, ch3);\r\n      \r\n   return 0;\r\n}\r\n</textarea>', 'ctype.h', 'int isgraph( int c)', 'int c	판별할 문자', '0 !=	c가 프린트 가능 문자, 공백문자는 제외 <br>0 =	c는 프린트 가능 문자가 아님', '인수로 받은 문자가 인쇄 가능 문자인지를 판별합니다.', ']$ ./a.out<br>\r\n1(x31)는 인쇄 가능 문자입니다.<br>\r\n(x20)는 인쇄 가능 문자가 아닙니다.<br>\r\n(x09)는 인쇄 가능 문자가 아닙니다.');
